{"version":3,"sources":["contained-periodic-values.js"],"names":[],"mappings":"WAAU,IAAI,EAAE,OAAO,EAAE;AACvB;AACE;;AAEA;AACA;;AAEA;;EAEH,iBAAiB,oBAAoB,EAAE;AACtC;;gCAIA,UAAiC,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,EAAE;;AAG1D,QAAI,KAAK,KAAK,GAAG,EAAE;AAAE,aAAO,CAAC,CAAC;KAAE;;;AAGhC,QAAI,KAAK,GAAG,GAAG,EAAE;AACf,UAAI,MAAM,GAAG,KAAK,CAAC;AACnB,WAAK,GAAG,GAAG,CAAC;AACZ,SAAG,GAAG,MAAM,CAAC;KACd;;;AAGD,OAAG,EAAE,CAAC;;AAEN,QAAI,OAAO,GAAG,oBAAoB,CAAC,KAAK,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;;;;AAIzD,QAAI,OAAO,GAAG,KAAK,GAAG,CAAC,EAAE;AACvB,aAAO,IAAI,MAAM,CAAC;KACnB;;;AAGD,QAAI,AAAC,OAAO,GAAG,KAAK,GAAK,GAAG,GAAG,KAAK,AAAC,EAAE;AACrC,aAAO,CAAC,CAAC;KACV;;;;SAII;AACH,aAAO,CAAC,GAAG,QAAQ,CAAC,CAAC,GAAG,GAAG,OAAO,CAAA,GAAI,MAAM,CAAC,CAAC;KAC/C;GACF;;;;;AAKD,SAAO,uBAAuB,CAAC;CAChC,CAAC,CAAC","file":"contained-periodic-values.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['nearest-periodic-value'], factory);\n  } else if (typeof exports !== 'undefined') {\n    var nearestPeriodicValue = require('nearest-periodic-value');\n    module.exports = factory(nearestPeriodicValue);\n  } else {\n    root.containedPeriodicValues = factory(root.nearestPeriodicValue);\n  }\n})(this, function(nearestPeriodicValue) {\n  'use strict';\n\n  import nearestPeriodicValue from 'nearest-periodic-value';\n  \n  function containedPeriodicValues(start, end, value, period) {\n  \n    // Inclusive start; exclusive end\n    if (start === end) { return 0; }\n  \n    // Flip our interval if it isn't ordered properly\n    if (start > end) {\n      var newEnd = start;\n      start = end;\n      end = newEnd;\n    }\n  \n    // Make our interval have an exclusive end\n    end--;\n    \n    var nearest = nearestPeriodicValue(start, value, period);\n  \n    // Ensure that the nearest value is in front of the start\n    // of the interval\n    if (nearest - start < 0) {\n      nearest += period;\n    }\n  \n    // If we can't even reach the first value, then it is 0\n    if ((nearest - start) > (end - start)) {\n      return 0;\n    }\n  \n    // Otherwise, we have reached it, so we start with 1.\n    // Then we add one for every full period in our interval\n    else {\n      return 1 + parseInt((end - nearest) / period);\n    }\n  }\n  \n  export default containedPeriodicValues;\n  \n  \n  return containedPeriodicValues;\n});\n"],"sourceRoot":"/source/"}